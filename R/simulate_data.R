#' @title Set simulation parameters of a study group.
#'
#' @description This function provides input arguments for each study group needed to simulate data with [simulate_data()].
#' [simulate_data()] generates data for a two-arms clinical trial with longitudinal continuous outcome and two intercurrent events (ICEs).
#'
#' @param mu Numeric vector indicating the mean outcome trajectory assuming no ICEs. It should include the outcome at baseline.
#' @param sigma Covariance matrix of the outcome trajectory assuming no ICEs.
#' @param n Number of subjects belonging to the group.
#' @param prob_ice1 Numeric vector that specifies for each visit the probability of experiencing ICE1 after the current visit for a subject with outcome equal to the mean at baseline.
#' If a single numeric is provided, then the same probability is applied to each visit.
#' @param or_outcome_ice1 Numeric number that specifies the odds ratio of ICE1 corresponding to a +1 higher value of the outcome at the visit.
#' @param prob_post_ice1_dropout Numeric number that specifies the drop-out probability following ICE1.
#' @param prob_dropout Numeric that specifies the probability that a post-baseline visit is affected by study drop-out. In case the subject is still on treatment at the subject's (first) visit affected drop-out,
#' then dropout also triggers discontinuation of study drug and a corresponding ICE called "ICE2" is generated.
#' @param prob_miss Numeric number that specifies the probability for a given post-baseline observation to be missing. It can be used to produce
#' "intermittent" missing values (which are missing completely at random).
#'
#' @details For the details, please see [simulate_data()].
#'
#' @return A `simul_pars` object which is a named list containing the simulation parameters.
#'
#' @seealso [simulate_data()]
#'
#' @export
set_simul_pars <- function(mu, sigma, n, prob_ice1 = 0, or_outcome_ice1 = 1, prob_post_ice1_dropout = 0, prob_dropout = 0, prob_miss = 0) {

    x <- list(
        mu = mu,
        sigma = sigma,
        n = n,
        prob_ice1 = prob_ice1,
        or_outcome_ice1 = or_outcome_ice1,
        prob_post_ice1_dropout = prob_post_ice1_dropout,
        prob_dropout = prob_dropout,
        prob_miss = prob_miss
    )

    class(x) <- "simul_pars"

    return(x)
}

#' @title Validate a `simul_pars` object
#'
#' @param x An `simul_pars` object as generated by [set_simul_pars()].
#' @param ... Not used.
#'
#' @export
validate.simul_pars <- function(x, ...) {

    assert_that(
        length(x) == 8,
        all(names(x) %in% c("mu", "sigma", "n", "prob_ice1", "or_outcome_ice1", "prob_post_ice1_dropout", "prob_dropout", "prob_miss")),
        msg = "`x` must be a named list of length 8"
    )
    assert_that(
        is.vector(x$mu) &&
            is.matrix(x$sigma) &&
            all(length(x$mu) == dim(x$sigma)),
        msg = "`mu` must be a numeric vector with length equal to the dimension of `sigma`"
    )
    assert_that(
        is.numeric(x$n) && x$n > 0,
        msg = "`n` must be a positive number"
    )
    assert_that(
        is.numeric(x$prob_ice1) && all(x$prob_ice1 >= 0 & x$prob_ice1 <= 1),
        msg = "each element of `prob_ice1` must be a number in [0,1]"
    )
    assert_that(
        length(x$prob_ice1) == 1 || length(x$prob_ice1) == length(x$mu),
        msg = "`prob_ice1` must have either length 1 or equal to the length of `mu`"
    )
    assert_that(
        is.numeric(x$or_outcome_ice1) && x$or_outcome_ice1 > 0,
        msg = "`or_outcome_ice1` must be a positive number"
    )
    assert_that(
        is.numeric(x$prob_post_ice1_dropout) && (x$prob_post_ice1_dropout >= 0 && x$prob_post_ice1_dropout <= 1),
        msg = "`prob_post_ice1_dropout` must be a number in [0,1]"
    )
    assert_that(
        is.numeric(x$prob_dropout) && (x$prob_dropout >= 0 && x$prob_dropout <= 1),
        msg = "`prob_dropout` must be a number in [0,1]"
    )
    assert_that(
        is.numeric(x$prob_miss) && (x$prob_miss >= 0 && x$prob_miss <= 1),
        msg = "`prob_miss` must be a number in [0,1]"
    )
}


#' @title Generate data
#'
#' @description Generate data for a two-arms clinical trial with longitudinal continuous outcome and two intercurrent events (ICEs).
#'
#' @param pars_c A `simul_pars` object as generated by [set_simul_pars()]. It specifies the simulation parameters of the control arm.
#' @param pars_t A `simul_pars` object as generated by [set_simul_pars()]. It specifies the simulation parameters of the treatment arm.
#' @param post_ice_traj Character that specifies the assumption about post-ICE1 outcomes.
#' Must target a function included in `strategies`. Possible choices are: Missing At Random `"MAR"`, Jump to Reference `"JR"`,
#' Copy Reference `"CR"`, Copy Increments in Reference `"CIR"`, Last Mean Carried Forward `"LMCF"`. User-defined strategies
#' could also be added. See [getStrategies()] for details.
#' @param strategies A named list of functions. Default equal to [getStrategies()]. See [getStrategies()] for details.
#'
#'
#' @details
#' The data generation works as follows:
#'
#' - Generate data from a multivariate normal distribution with parameters `pars_c$mu` and `pars_c$sigma`
#' for the control arm and parameters `pars_t$mu` and `pars_t$sigma` for the treatment arm.
#' - Simulate ICE1 according to the given logistic model for the probability of ICE1. ICE1 could often represent treatment discontinuation due to study-related events.
#' - Simulate drop-out following ICE1 according to `pars_c$prob_post_ice1_dropout` and `pars_t$prob_post_ice1_dropout`. This drop-out is conditional on ICE1 and is simulated completely at random.
#' - Simulate an additional uninformative study drop-out with probabilities `pars_c$prob_dropout` and `pars_t$prob_dropout` at each visit.
#'   The simulated time of drop-out is the subject's first visit which is affected by drop-out and data from this visit and all subsequent visits are consequently set to missing.
#'   In addition, in case the subject is still on treatment at the subject's (first) visit affected drop-out,
#'   then dropout also triggers discontinuation of study drug and a corresponding ICE called "ICE2" is generated. ICE2 could often represent treatment discontinuation
#'   due to events not related to the study.
#' - Adjust trajectories after the ICEs according to the given assumption expressed with the `post_ice_traj` argument.
#'
#' The model for the probability of experiencing ICE1 is:
#' `~ 1 + I(visit == 0) + ... + I(visit == n_visits-1) + I((x-alpha))` where:
#' - `n_visits` is the number of visits (including baseline).
#' - `alpha = mu_c[1]` or `alpha = mu_t[1]`: `alpha` is the baseline outcome mean in the control arm if the subject belongs to the control arm. Otherwise it is the baseline outcome mean in the treatment arm.
#' The term `I((x-alpha))` specifies the dependency of the probability of ICE1 on the current outcome value.
#' The corresponding coefficient is `log(pars_c$or_outcome_ice1)` (or `log(pars_t$or_outcome_ice1)`) which represents the increase of the ICE1 probability
#' due to a +1 higher value of the outcome at the visit. `pars_c$or_outcome_ice1` and `pars_t$or_outcome_ice1` are the odds ratio corresponding to such increase in the outcome for the two groups.
#'
#' Please note that the baseline outcome cannot be missing nor be affected by any ICEs.
#'
#' @returns A `data.frame` containing the simulated data. It includes the following variables:
#' - `id`: Factor variable that specifies the id of each subject.
#' - `visit`: Factor variable that specifies the visit of each assessment. Visit `0` denotes the baseline visit.
#' - `group`: Factor variable that specifies which treatment group each subject belongs to.
#' - `out_bl`: Numeric variable that specifies the baseline outcome.
#' - `out_noICE`: Numeric variable that specifies the longitudinal outcome assuming no ICEs.
#' - `ind_ice1`: Binary variable that takes value `1` if the corresponding visit is affected by ICE1 and `0` otherwise.
#' - `dropout_ice1`: Binary variable that takes value `1` if the corresponding visit is affected by the drop-out following ICE1 and `0` otherwise.
#' - `out_ice1`: Numeric variable that specifies the longitudinal outcome including ICE1.
#' - `dropout2`: Binary variable that takes value `1` if the corresponding visit is affected by the uninformative study drop-out.
#' - `ind_ice2`: Binary variable that takes value `1` if the corresponding visit is affected by ICE2.
#' - `outcome`: Numeric variable that specifies the longitudinal outcome including ICE1, ICE2 and the intermittent missing values.
#'
#' @export
simulate_data <- function(pars_c, pars_t, post_ice_traj, strategies = getStrategies()) {

    assert_that(
        has_class(pars_c, "simul_pars"),
        has_class(pars_t, "simul_pars"),
        msg = "`pars_c` and `pars_t` must be of class `simul_pars`"
    )
    validate(pars_c)
    validate(pars_t)
    assert_that(
        length(pars_c$mu) == length(pars_t$mu),
        msg = "The two groups must have the same number of visits"
    )

    # TODO: validate user-defined strategies
    match.arg(
        arg = post_ice_traj,
        choices = names(strategies)
    )
    strategy_fun <- strategies[[which(names(strategies) == post_ice_traj)]]

    data_c <- generate_data_single(pars_c, strategy_fun)
    data_t <- generate_data_single(
        pars_t,
        strategy_fun,
        distr_pars_ref = list(mu = pars_c$mu, sigma = pars_c$sigma)
    )

    data <- rbind(data_c, data_t)

    n_visits <- length(pars_c$mu)
    # overwrite ids to have unique ids
    data$id <- rep(paste0("id_", seq.int(pars_c$n + pars_t$n)), each = n_visits)
    # add group variable
    data$group <- rep(c(rep("Control", pars_c$n), rep("Intervention", pars_t$n)), each = n_visits)

    return(data)
}


#' Generate data for a single group
#'
#' @param pars_group A `simul_pars` object as generated by [set_simul_pars()]. It specifies the simulation parameters of the given group.
#' @param strategy_fun Function implementing trajectories after the intercurrent event (ICE). Must be one of [getStrategies()]. See [getStrategies()] for details.
#' @param distr_pars_ref Optional. Named list containing the simulation parameters of the reference arm. It contains the following elements:
#' - `mu`: Numeric vector indicating the mean outcome trajectory assuming no ICEs. It should include the outcome at baseline.
#' - `sigma` Covariance matrix of the outcome trajectory assuming no ICEs.
#' If `NULL`, then these parameters are inherited from `pars_group`.
#'
#' @inherit simulate_data return
#'
#' @seealso [simulate_data()].
generate_data_single <- function(pars_group, strategy_fun, distr_pars_ref = NULL) {

    n_visits <- length(pars_group$mu)

    data <- data.frame(
        id = as.factor(rep(paste0("id_", seq.int(pars_group$n)), each = n_visits)),
        visit = as.factor(rep(seq.int(n_visits)-1, pars_group$n)),
        group = as.factor(rep("g", pars_group$n)),
        out_bl = NA,
        out_noICE = c(replicate(pars_group$n, sample_mvnorm(pars_group$mu, pars_group$sigma)))
    )
    data$out_bl <- rep(data$out_noICE[data$visit == "0"], each = n_visits)

    data$ind_ice1 <- simulate_ice(
        outcome = data$out_noICE,
        visits = data$visit,
        ids = data$id,
        prob_ice = pars_group$prob_ice,
        or_outcome_ice = pars_group$or_outcome_ice1,
        baseline_mean = pars_group$mu[1]
    )

    # return binary vector with "1" where first ICE1 visit
    first_ice1_visit <- unlist(
        tapply(data$ind_ice1, factor(data$id, levels = unique(data$id)), function(x) {
            subset <- rep(0, n_visits)
            if(any(x == 1)) {
                ind <- which(x==1)[1]
                subset[ind] <- 1
            }
            return(subset)
        }
        ))

    data$dropout_ice1 <- simulate_dropout(
        prob_dropout = pars_group$prob_post_ice1_dropout,
        ids = data$id,
        subset = first_ice1_visit
    )

    data$out_ice1 <- adjust_trajectories(
        distr_pars_group = list(mu = pars_group$mu, sigma = pars_group$sigma),
        outcome = data$out_noICE,
        ids = data$id,
        ind_ice = data$ind_ice1,
        strategy_fun = strategy_fun,
        distr_pars_ref = distr_pars_ref
    )
    data$out_ice1[data$dropout_ice1 == 1] <- NA

    data$dropout2 <- simulate_dropout(
        prob_dropout = pars_group$prob_dropout,
        ids = data$id
    )
    # ICE2 happens if a subject is on treatment and drops-out
    data$ind_ice2 <- unlist(lapply(split(data[,c("ind_ice1", "dropout2")], factor(data$id, levels = unique(data$id))), function(x) pmin(cumsum(ifelse(x$ind_ice1 == 0, 1, 0)*x$dropout2), 1)))

    data$outcome <- data$out_ice1
    data$outcome[data$dropout2 == 1] <- NA

    rand_miss <- rbinom(n = pars_group$n*(n_visits-1), size = 1, prob = pars_group$prob_miss)
    data$outcome[data$visit != "0"][rand_miss == 1] <- NA

    return(data)
}


#' Simulate intercurrent event
#'
#' @param outcome Numeric variable that specifies the longitudinal outcome for a single group.
#' @param visits Factor variable that specifies the visit of each assessment.
#' @param ids Factor variable that specifies the id of each subject.
#' @param prob_ice Numeric vector that specifies for each visit the probability of experiencing the ICE after the current visit for a subject with outcome equal to the mean at baseline.
#' If a single numeric is provided, then the same probability is applied to each visit.
#' @param or_outcome_ice Numeric number that specifies the odds ratio of the ICE corresponding to a +1 higher value of the outcome at the visit.
#' @param baseline_mean Mean outcome value at baseline.
#'
#' @details The probability of the ICE at each visit is modeled according to the following logistic regression:
#' `~ 1 + I(visit == 0) + ... + I(visit == n_visits-1) + I((x-alpha))` where:
#' - `n_visits` is the number of visits (including baseline).
#' - `alpha` is the baseline outcome mean set with `baseline_mean`.
#' The term `I((x-alpha))` specifies the dependency of the probability of the ICE on the current outcome value.
#' The corresponding coefficient is `log(or_outcome_ice)` which represents the increase of the ICE probability
#' due to a +1 higher value of the outcome at the visit.
#'
#' @return A binary variable that takes value `1` if the corresponding outcome is affected by the ICE and `0` otherwise.
#'
#' @importFrom stats rbinom model.matrix
simulate_ice <- function(outcome, visits, ids, prob_ice, or_outcome_ice, baseline_mean) {

    assert_that(
        is.factor(visits) && length(visits) == length(outcome),
        msg = "`visits` must be a factor of length equal to the length of `outcome`"
    )

    assert_that(
        is.factor(ids) && length(ids) == length(outcome),
        msg = "`ids` must be a factor of length equal to the length of `outcome`"
    )

    n_visits <- nlevels(visits)
    if(length(prob_ice == 1)) {
        prob_ice <- rep(prob_ice, n_visits)
    }
    prob_ice[prob_ice == 0] <- 1e-20

    create_model_ice <- function(n_visits, baseline_mean) {
        model_ice <- "~ 1"
        for(visit_num in seq.int(n_visits) - 1) {
            model_ice <- paste0(model_ice, " + I(visit == ", visit_num,")")
        }
        model_ice <- paste0(model_ice, " + I((x - ", baseline_mean,"))")
        return(as.formula(model_ice))
    }

    model_ice <- create_model_ice(
        n_visits = n_visits,
        baseline_mean = baseline_mean
    )

    model_coef <- c(0, log(prob_ice/(1-prob_ice)), log(or_outcome_ice))

    lp <- c(model.matrix(model_ice, data.frame("visit" = visits, "x" = as.numeric(outcome)))%*%model_coef) # linear predictor
    probs_ice <- binomial(link = "logit")$linkinv(lp)
    ind_ice <- rbinom(n = length(ids), size = 1, prob = probs_ice)
    ind_ice <- unlist(tapply(ind_ice, factor(ids, levels = unique(ids)), function(x) c(0, pmin(cumsum(x), 1))[-(length(x) + 1)]))
    names(ind_ice) <- NULL

    return(ind_ice)
}


#' Simulate drop-out
#'
#' @param prob_dropout Numeric that specifies the probability that a post-baseline visit is affected by study drop-out.
#' @param ids Factor variable that specifies the id of each subject.
#' @param subset Binary variable that specifies the subset that could be affected by drop-out. I.e. `subset` is a binary vector
#' of length equal to the length of `ids` that takes value `1` if the corresponding visit could be affected by drop-out and `0` otherwise.
#'
#' @return A binary vector of length equal to the length of `ids` that takes value `1` if the corresponding outcome is
#' affected by study drop-out.
#'
#' @details `subset` can be used to specify outcome values that cannot be affected by the drop-out. If `NULL` then
#' `subset` will be set to `1` for all the values except the values corresponding to the baseline outcome, since baseline is supposed to not be affected by drop-out.
#' Even if `subset` is specified by the user, the values corresponding to the baseline outcome are still hard-coded to be `0`.
#'
#' @importFrom stats rbinom
simulate_dropout <- function(prob_dropout, ids, subset = NULL) {

    if(is.null(subset)) {
        subset <- rep(1, length(ids))
        # baseline values cannot be missing
        subset <- unlist(tapply(subset, factor(ids, levels = unique(ids)), function(x) {
            x[1] <- 0
            return(x)
        }
        ))
    } else {
        # baseline values cannot be missing
        subset <- unlist(tapply(subset, factor(ids, levels = unique(ids)), function(x) {
            x[1] <- 0
            return(x)
        }
        ))
    }

    dropout <- rep(0, length(ids))
    dropout[subset == 1] <- rbinom(n = sum(subset), size = 1, prob = prob_dropout)
    dropout <- unlist(tapply(dropout, factor(ids, levels = unique(ids)), function(x) pmin(cumsum(x), 1)))
    return(dropout)
}


#' Adjust trajectories due to the intercurrent event (ICE)
#'
#' @param distr_pars_group Named list containing the simulation parameters of the multivariate normal distribution assumed for the given treatment group. It contains the following elements:
#' - `mu`: Numeric vector indicating the mean outcome trajectory. It should include the outcome at baseline.
#' - `sigma` Covariance matrix of the outcome trajectory.
#' @param outcome Numeric variable that specifies the longitudinal outcome.
#' @param ids Factor variable that specifies the id of each subject.
#' @param ind_ice A binary variable that takes value `1` if the corresponding outcome is affected by the ICE and `0` otherwise.
#' @param strategy_fun Function implementing trajectories after the intercurrent event (ICE). Must be one of [getStrategies()]. See [getStrategies()] for details.
#' @param distr_pars_ref Optional. Named list containing the simulation parameters of the reference arm. It contains the following elements:
#' - `mu`: Numeric vector indicating the mean outcome trajectory assuming no ICEs. It should include the outcome at baseline.
#' - `sigma` Covariance matrix of the outcome trajectory assuming no ICEs.
#'
#' @return A numeric vector containing the adjusted trajectories.
#'
#' @seealso [adjust_trajectories_single()].
#'
adjust_trajectories <- function(distr_pars_group, outcome, ids, ind_ice, strategy_fun, distr_pars_ref = NULL) {

    outcome[ind_ice == 1] <- NA
    outcome <- unlist(tapply(outcome, factor(ids, levels = unique(ids)), function(x) adjust_trajectories_single(
        outcome = x,
        distr_pars_group = distr_pars_group,
        strategy_fun = strategy_fun,
        distr_pars_ref = distr_pars_ref
    )
    ))

    return(outcome)
}


#' Adjust trajectory of a subject's outcome due to the intercurrent event (ICE)
#'
#' @param distr_pars_group Named list containing the simulation parameters of the multivariate normal distribution assumed for the given treatment group. It contains the following elements:
#' - `mu`: Numeric vector indicating the mean outcome trajectory. It should include the outcome at baseline.
#' - `sigma` Covariance matrix of the outcome trajectory.
#' @param outcome Numeric variable that specifies the longitudinal outcome.
#' @param strategy_fun Function implementing trajectories after the intercurrent event (ICE). Must be one of [getStrategies()]. See [getStrategies()] for details.
#' @param distr_pars_ref Optional. Named list containing the simulation parameters of the reference arm. It contains the following elements:
#' - `mu`: Numeric vector indicating the mean outcome trajectory assuming no ICEs. It should include the outcome at baseline.
#' - `sigma` Covariance matrix of the outcome trajectory assuming no ICEs.
#'
#' @return A numeric vector containing the adjusted trajectory for a single subject.
#'
#' @details `outcome` should be specified such that all-and-only the post-ICE observations (i.e. the
#' observations to be adjusted) are set to `NA`.
#'
adjust_trajectories_single <- function(distr_pars_group, outcome, strategy_fun, distr_pars_ref = NULL) {

    is_post_ice <- is.na(outcome)
    if(all(!is_post_ice)) {
        return(outcome)
    }

    if(is.null(distr_pars_ref)) {
        distr_pars_ref <- distr_pars_group
    }

    pars <- strategy_fun(
        pars_group = distr_pars_group,
        pars_ref = distr_pars_ref,
        index_mar = !is_post_ice
    )

    conditional_parameters <- get_conditional_parameters(pars, outcome)
    outcome[is_post_ice] <- impute_outcome(conditional_parameters)
    return(outcome)
}
